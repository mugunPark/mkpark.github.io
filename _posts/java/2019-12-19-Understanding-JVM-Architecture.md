---
title: "JVM Architecture 이해"
classes: wide
excerpt: "[원문] Understanding JVM Architecture"
header:
  overlay_image: /assets/images/develop-unsplash.jpg
  overlay_filter: rgba(255, 255, 255, 0.3)
  actions:
    - label: "Go to"
      url: "https://medium.com/platform-engineer/understanding-jvm-architecture-22c0ddf09722"
categories:
  - Java
tags:
  - JVM
last_modified_at: 2019-12-19T18:24:00
---
JVM 아키텍처의 이해와 Java가 내부에서 실제로 어떻게 동작하는지는 Java 생태계(Java ecosystem)를 효과적으로 활용하기위해 모든 Java 개발자에게 중요한 학습입니다.
이 포스트에서는 Java 생태계와 관련된 JVM 내부 및 기술의 기초를 제공할 것입니다.

# 배경 지식

Sun Microsystems의 James Gosling에 의해 1955년에 디자인된 자바는 수백만의 개발자에게 사랑받는 multi-paradigm 프로그래밍 언어입니다. Java는 15년간 가장 인기있는 언어이다.지난 15년 동안 개발된 수만의 엔터프라이즈 어플리케이션은 대부분 Java로 작성되었고, 엔터프라이즈 급 제품의 소프트웨어 시스템 구축할 때 선택하는 언어가 되었습니다.

# Java 환경

거의 모든 프로그래밍 언어의 경우, 모든 필요한 컴포넌트 구성, 어플리케이션 프로그래밍 인터페이스, 그리고 개발을 위한 라이브러리, 컴파일, 디버깅, 프로그램 실행과 같은 특별한 환경이 필요합니다. Java는 2가지 환경이 있고 Java를 사용하는 모든 사람은 이러한 환경 중 하나를  로컬 개발 또는 도구 환경 플랫폼으로 설정한 이후에 작업을 시작합니다.
-	JRE (Java Runtime Environment): Java 어플리케이션 실행에 필요한 최소 환경(개발에 대한 지원은 없음). JVM (Java Virtual Machine)과 배포 툴을 포함합니다.
-	JDK (Java Development Kit): Java 어플리케이션 개발과 실행에 사용되는 완전한 개발 환경. JRE와 개발 툴 둘 다 포함합니다.
JRE는 사용자를 위한 것이고, JDK는 개발자를 위한것입니다.

# 어떻게 Java는 동작하는가?

터미널 에디터(vim, nano) 또는 GUI editor(gedit, sublime)으로 간단한 Java 프로그램 작성을 시작할 수 있습니다. 복잡한 Java 어플리케이션의 경우, IntelliJ IDEA, Eclipse, Netbeans와 같은 IDE(Integrated Development Environment)가 필요할 것입니다. 일반 Java 프로그램은 올바른 언어 문법과 .java 형식을 포함해야 합니다. Java 프로그램의 구조와 유지보수의 편리함을 위해 OOP(Object Oriented Programming)와 같은 프로그래밍 개념과 적당한 아키텍처의 패턴을 사용하는 것을 추천합니다.

Java의 주요 강점은 WORA(write once, run anywhere) 개념과 함께 다양한 플랫폼에서 실행되게 디자인되었습니다.
비록 C++과 같은 언어들은 단지 특정 플랫폼과 일치하게 소스 코드를 컴파일하고, OS와 하드웨어에서 기본적으로 실행하지만, Java 소스 코드는 JDK와 함께 제공되는 Java Compiler(javac)를 사용하여 `bytecode`로 불리는 JVM이 이해할 수 있는 언어로 컴파일 됩니다. 이 `bytecode`는 [opcode-operand](https://mylearningmania.blogspot.com/2018/05/opcode-and-operand.html)라인들의 16진수 형태이고, JVM은 이런 명령들을 OS와 하드웨어 플랫폼에 의해 이해될 수 있는 기본 기계 언어의 해석할 수 있습니다. 그러므로 `bytecode`는 OS와 하드웨어 아키텍처에 상관없이 어떤 JVM에도 이식가능한 플랫폼 독립적인 중간 상태로 작동합니다. 하지만, JVM들은 OS와 하드웨어 구조와 실행 및 통신하도록 개발되었으므로, OS version(Windows, Linux, Max)과 프로세서 아키텍처(x86, x64)에 맞는 적당한 JVM 버전 선택이 필요합니다.

우리 대부분은 위의 Java 이야기를 알고있으며 여기서 문제는 이 프로세스의 가장 중요한 구성요소 입니다. JVM은 바이트 코드를 마술처럼 해석하고 프로그램 실행 중 JIT(Just-in-Time) 컴파일 및 GC(Garbage Collection)과 같은 많은 런타임 활동을 수행 할 수 있는 블랙 박스로 우리에게 가르쳐줍니다. 이제 JVM 작동 방식을 알아보겠습니다. 

# JVM 아키텍처

JVM은 사양일 뿐이며 구현은 밴더 마다 다릅니다. 지금은 사양에 정의된 것처럼 JVM의 일반적으로 받아들여지는 아키텍처를 이해해봅시다.

![image-center]({{ site.url }}{{ site.baseurl }}/assets/images/JVM Architecture.png){: .align-center}


## 1) Class Loader Subsystem

JVM은 RAM에 있습니다. Class Loader subsystem을 사용하여 실행하는 동안 class 파일들은 RAM에서 가져옵니다. 이는 Java의 `dynamic class loading` 기능이라고 합니다.
그것은 런타임(컴파일 타임은 아님) 에 class를 최초로 참조할 때 class 파일(.class)을 로드, 링크, 초기화 합니다.

### 1.1) Loading

컴파일 된 class 파일들을 로딩하는 것은 `Class Loader`의 주요 작업입니다. 일반적으로 클래스 로딩 프로세스는 main 클래스(`static main()` 메소드가 선언된 클래스)로부터 시작됩니다. 모든 이후 클래스 로딩 시도는 아래의 경우에 말하는 것처럼 이미 실행 중인 클래스들에서 클래스 참조 따라 이루어집니다.

*	바이트 코드가 class에 대한 정적 참조를 만들 때(e.g. `System.out`)

*	바이트 코드가 클래스 객체를 생성할 때(e.g. `Person person = new Person(“John”)`)

클래스 로더(상속으로 연결된)는 3가지 타입이 있고, 4가지 주요 원칙을 따릅니다.

*1.1.1	가시성 원칙(Visibility Principle)*

이 원칙은 자식 클래스 로더는 부모 클래스에 의해 로드된 클래스를 볼 수 있다는 것을 말합니다. 그러나 부모 클래스 로더는 자식 클래스 로더에 의해 로드된 클래스를 찾을 수 없습니다.

*1.1.2	유일함 원칙(Uniqueness Principle)*

이 원칙은 부모에서 로드된 클래스는 자식 클래스 로더에서 다시 로드 될 수 없고, 중복 클래스 로드가 발생하지 않는 다는 것을 보증해야 한다는 것을 말합니다.

*1.1.3	위임 계층 원칙(Delegation Hierarchy Principle)*

위의 두 원칙을 충족시키기 위해, JVM은 위임 계층 구조에 따라 각 클래스 로딩 요청에 대한 클래스 로더를 선택합니다. 여기서 가장 하위 레벨의 `Application Class Loader`로부터 시작하고, `Application Class Loader`는 클래스 로딩을 요청을 `Extension Class Loader`에 위임하고, 그 다음 `Extension Class Loader`는 요청을 `Bootstrap Class Loader`에게 위임합니다. 요청 받은 클래스를 `Bootstrap` 경로에서 찾는다면 클래스를 로드합니다. 그렇지 않으면 요청은 Extension 경로 또는 사용자 지정 경로에서 클래스를 찾기 위해 `Extension Class Loader` 로 다시 전달합니다. 여기서도 찾지 못한다면, 요청은 `System` 클래스 경로에서 찾기 위해 `Application Loader`로 돌아오고, `Application Class Loader`에서도 요청받은 클래스를 로드하는것에 실패하게되면, 런타임오류(`java.lang.ClassNotFoundException `)를 보게됩니다.

*1.1.4	No Unloading 원칙(No Unloading Principle)*

클래스 로더는 클래스를 로드할 수 는 있지만, 로드한 클래스를 언로드(unload) 할 수 없습니다. 언로드를 대신해서 현재 클래스 로더는 제거 될 수 있고, 새로운 클래스 로더가 생성될 수 있습니다.

![image-center]({{ site.url }}{{ site.baseurl }}/assets/images/class loader view.png){: .align-center}

*	`Bootstrap Class Loader`는 bootstrap 경로($JAVA_HOME/jre/lib directory e.g. java.lang.* package classes.)의 핵심 Java API 클래스를 제공하는 `rt.jar`로부터 표준 JDK 클래스들을 로드 합니다. 이는 C/C++과 같은 native 언어로 구현되어있고 Java에서 모든 클래스 로더의 부모 역할을 합니다.

*	`Extension Class Loader` 는 클래스 로딩 요청을 부모 로더인 `Bootstrap`에게 위함하고, 만약 로드하지 못하면 확장 경로의 폴더로부터 클래스를 로드합니다. 확장 경로는 `$JAVA_HOME/jre/lib/ext` 또는 ` java.ext.dirs` system property로 지정된 다른 경로를 의미합니다. 이 클래스 로더는  `sun.misc.Launcher$ExtClassLoader` 클래스로 자바에서 구현되었습니다. 

*	`System/Application Class Loader`는 시스템 클래스 경로로부터 어플리케이션 별 클래스를 로드합니다. 그것은 프로그램을 실행할 때 `-cp` 또는 `-classpath` 커맨드라인 옵션을 사용하여 설정할 수 있습니다. 그것은 내부적으로 `java.class.path`에 매핑되는 `Envioronment Value`를 사용합니다. 이 클래스 로더는 `  sun.misc.Launcher$AppClassLoader` 클래스로 Java에서 구현되었습니다


참고: 위에서 설명한 3가지 주요 클래스 로더 외에  프로그래머는 직접 사용자 정의 클래스 로더를 생성할 수 있습니다. 이는 클래스 로더 위임 모델을 통해 어플리케이션의 독립을 보장합니다. 이러한 접근법은 웹 앱을 만드는 Tomcat 과 같은 웹 어플리케이션 서버와 독립적으로 실행하는 엔터프라이즈 솔루션에 사용됩니다.

각 클래스 로더는 로드된 클래스를 저장하는 로더만의 `namespace` 를 가집니다. 클래스 로더가 클래스를 로드할 때, 클래스가 이미 로드되었는지 여부를 확인하기위해 namespace에 저장된 FQCN(Fully Qualified Class Name)을 기반으로 클래스를 검색합니다. 클래스가 동일한 FQCN을 가지지만 namespace 다른 경우에도 그것은 다른 클래스로 간주됩니다. Namespace가 다르다는 것은 클래스가 또다른 클래스 로더에 의해 로드되었다는 것을 의미합니다.

### 1.2) Linking

Linking은 로드된 클래스 또는 인터페이스의, 직접적인 superclass들과 superinterfaces들 그리고 필요에 따라 요소 유형을 검증하고 준비하는 과정에서 아래 속성을 따릅니다.

*	클래스 또는 인터페이스는 링크되기 전에 반드시 완전히 로드되어야 합니다.

*	클래스 또는 인터페이스는 초기화 전에 반드시 완전하게 검증과 준비가 되어야 합니다.

*	Linking에서 에러가 발생하면 프로그램에서 어떤 조치를 취할 수있는 프로그램의 특정 지점에서 발생합니다. 그것은 아마 직간접적으로 오류와 관련된 클래스 또는 인터페이스에 연결할 수 있습니다.

Linking은 아래의 3가지 단계로 이루어집니다.

*	검증(Verification): .class 파일의 정확성을 보장합니다. (코드가 Java Language Specification에 따라 작성했는지, JVM Specification에 따라 유효한 컴파일러에 의해 만들어진 것인지)
이것은 클래스 로드 절차에서 가장 복잡한 테스트 절차이고 가장 오랜 시간이 걸립니다. Linking이 클래스 로딩 절차를 느려지게 할지라도 그것은 바이트 코드를 실행할 때 이러한 검사를 실행하는 필요가 없습니다. 이러한 이유로 전체 실행이 효율적이고 효과적입니다. 만약 검증에 실패하면 런타임 오류(`java.lang.VerifyError)가 발생합니다. 예를 들어 다음과 같은 확인이 수행됩니다.

```
- consistent and correctly formatted symbol table
- final methods / classes not overridden
- methods respect access control keywords
- methods have correct number and type of parameters
- bytecode doesn’t manipulate stack incorrectly
- variables are initialized before being read
- variables are a value of the correct type
```

*	준비(Preparation): 정적 저장소 및 메소드 테이블과 같은 JVM에 의해 사용하는 모든 데이터 구조에 메모리를 할당. 정적 필드는 그것들의 기본 값으로 생성되고 초기화 됩니다. 하지만 이니셜라이저 또는 코드는 초기화의 일부로 발생하는 이 단계에서는 실행되지 않습니다.

*	해결(Resolution): symbolic 참조를 타입의 직접 참조로 변경합니다. 참조된 엔티티가 위치하고있는 메소드 영역에서 검색합니다.

### 1.3) Initialization
	여기서 각 로드된 클래스 또는 인터페이스의 초기화 로직이 실행될 것입니다(e.g. 클래스의 생성자 호출). 이후 JVM은 멀티 스레드이고, 클래스 또는 인터페이스의 초기화는 적절한 동기화로 다른 스레드에서 같은 클래스 또는 인터페이스 초기화하는 것을 피할 수 있게 신중하게 이루어져야 합니다(즉, Thread safe 해야함). 
모든 정적 변수는 코드에 정의된 원래 값으로 할당되고, 정적 블록이 실행될 경우 클래스 로딩의 마지막 단계입니다. 이는 클래스에서 위에서 아래로 한 줄 한 줄 실행되고, 클래스 계층에서 부모 클래스에서 자식 클래스로 실행됩니다.

## 2) 런타임 데이터 영역 (Runtime Data Area)

런타임 데이터 영역은 OS에서 JVM 프로그램이 실행될 때 할당되는 메모리 영역입니다. 이외에 `.class` 파일을 읽고, 클래스 로더 시스템은 바이너리 데이터를 만들고, 각각의 클래스 별로 메소드 영역에 다음의 정보를 저장합니다.

*	로드된 클래스의 정규화 된 이름(Fully qualified name)과 직계 부모 클래스

*	`.class` 파일이 클래스/인터페이스/Enum과 관련되어 있는지 여부

*	한정자, 정적 변수 그리고 메소드 정보 등등.

이때, 로드된 모든 `.class`의 경우, `java.lang` 패키지에 정의된 것과 같이 힙 메모리에 파일을 나타내는 클래스의 정확한 하나의 객체로 생성합니다. 이 클래스 객체는 클래스 정보(클래스 이름, 부모 이름, 메소드, 변수 정보, 정적 변수 정보 등등.)를 이후 코드에서 읽는데 사용될 수 있습니다.

### 2.1) 메소드 영역(스레드 간에 공유되는)

메소드 영역은 공유되는 자원(JVM당 오직 하나의 메소드 영역) 입니다. 모든 JVM 스레드들은 동일한 메소드 영역을 공유 하고, 그렇기 때문에 메소드 데이터에 접근과 동적 링킹 프로세스는 thread safe 해야만 합니다.

메소드 영역은 다음과 같은 클래스 레벨 데이터를 저장합니다.

*	클래스 로더 참조

*	런타임 상수 풀(constant pool) – 숫자 상수, 필드 참조, 메소드 참조, 속성뿐만 아니라 각 클래스 인터페이스 상수, 메소드와 필드의 모든 참조를 포함합니다. 메소드 또는 필드가 사용될 때, JVM은 메모리의 메소드 또는 필드의 실제 주소를 런타임 상수 풀을 사용하여 찾습니다.

*	필드 데이터 – 필드 별: 이름, 타입, 한정자, 속성

*	메소드 데이터 – 메소드 별: 이름, 리턴 타입, 파라미터 타입(순서 대로), 한정자, 속성

*	메소드 코드 – 메소드 별: 바이트 코드, 피연산자 스택 사이즈, 로컬 변수 사이즈, 로컬 변수 테이블, 예외 테이블; 예외 테이블에서 오류 핸들러 별: 시작/끝 위치, 핸들러 코드의 오프셋,  잡힌 예외 클래스의 상수 풀 인덱스

### 2.2) 힙 영역(스레드 간 공유되는)

힙 영역 역시 공유되는 자원(JVM당 오직 하나의 메소드 영역) 입니다. 모든 객체, 인스턴스 변수, 배열의 정보는 힙 영역에 저장됩니다. 이후 메소드와 힙 영역은 메모리를 멀티 스레드에서 공유하고, 메소드와 힙 영역에 저장된 데이터는 thread safe 하지 않습니다. 힙 영역은 GC 대상 입니다.

### 2.3) 스택 영역(스레드 별)

스택 영역은 공유되는 자원이 아닙니다. 모든 JVM 스레드의 경우 스레드가 시작할 때 메소드 호출을 저장하기위해 생성된 구분되는 런타임 스택을 가집니다. 이러한 모든 메소드 호출의 경우, 엔트리는 런타임 스택 최상위에 생성 또는 추가 될 것이고, 이러한 엔트리는 스택 프레임(Stack Frame) 이라고 합니다.
각 스택 프레임은 실행되는 메소드가 속하는 클래스의 로컬 변수 배열, 피연산자 스택 그리고 런타임 상수 풀에 대한 참조 가집니다.

프레임은 메소드가 리턴하거나 잡히지 않은 예외(uncaught exception)이 메소드 실행 동안 throw되면 제거됩니다. 또한 예외가 발생하면 stack trace(printStackTrace() 메소드로 볼 수 있음)의 각 라인은 하나의 스택 프레임에 표현됩니다. 스택 영역은 공유되는 자원이 아니므로 thread safe 합니다.

![image-center]({{ site.url }}{{ site.baseurl }}/assets/images/Stack Area.png){: .align-center}

스택 프레임은 안에서 3개의 서브 엔트리로 나뉩니다.

*	로컬 변수 배열 –인덱스는 0부터 시작합니다. 특별한 메소드의 경우 많은 로컬 변수가 연관되고, 변수가 여기에 저장됩니다. 0은 메소드가 포함된 클래스 인스턴스의 참조입니다. 1부터는 메소드에 전달된 파라미터가 저장됩니다. 메소드 파라미터 뒤에 메소드 로컬 변수가 저장됩니다. 

*	피연산자 스택 – 요구 사항이 있는 경우 중간 작업을 수행하기위한 런타임 작업공간과 같은 역할을 합니다. 각 메소드는 데이터를 피연산자 스택과 로컬 변수 배열 사이에서 교환하고, 다른 메소드 실행 결과를 push 또는 pop 합니다. 피연산자 스택 공간의 필요한 사이즈는 컴파일하는 동안에 결정될 수 있습니다. 그러므로, 피연산자 스택의 사이즈 또한 컴파일하는 동안에 결정될 수 있습니다.

*	프레임 데이터 – 메소드와 관련된 모든 심볼들은 여기에 저장됩니다. 예외의 경우, 캐치 블록 정보 또한 프레임 데이터에서 유지될 것입니다.

이것들은 스택 프레임이기 때문에, 스레드가 종료된 후에 스레드의 스택 프레임 또한 JVM에 의해 소멸됩니다.

스택은 동적또는 정해진 사이즈 일수 있습니다. 스레드가 허용된 것보다 더 큰 스택을 요구한다면 `StackOverflowError`이 발생합니다. 스레드가 새로운 프레임을 요구하고 할당하기 위한 충분한 메모리가 없으면 `OutOfMemoryError`이 발생합니다.

### 2.4) PC Registers (스레드 별)

JVM 스레드의 경우, 스레드가 시작할 때 별도의 PC(Program Counter)  Registers는 현재 실행중인 명령의 주소(메소드 영역에서의 메모리 주소)를 보관하기위해 생성됩니다. 현재 메소드가 Native 메소드 이면 PC는 정의되지 않습니다. 실행이 완료되면, PC register는 다음 명령의 주소로 업데이트 됩니다.

### 2.5) Native Method Stack (스레드 별)

Java 스레드와 기본 운영 체제 스레드 간의 직접적인 매핑이 있습니다. 이후 Java 스레드를 위한 모든 상태가 준비되면, 별도의 native stack 또한 JNI(Java Native Interface)를 통해 호출된 native 메소드 정보(보통C/C++로 작성됨)를 저장하기 위해 생성됩니다.

Native 스레드가 생성되고 초기화되면, Java 스레드에서 `run()` 메소드를 호출합니다.  `run()` 메소드가 리턴 할 때 예외가 있다면 처리되고, 그런 다음 native 스레드는 스레드 종료의 결과로 JVM이 종료될 필요가 있는지 확인합니다. 스레드가 종료되면 native와 Java 스레드의 모든 자원은 해제됩니다.

Native 스레드는 Java 스레드가 종료된 후에 종료됩니다. 그러므로 운영 체제는 모든 스레드를 스케줄링하고 사용 가능한 CPU로 디스 패치 해야 하는 책임이 있습니다.

## 3) 실행 엔진 (Execution Engine)

실제 바이트코드의 실행은 여기서 발생합니다. 실행 엔진은 런타임 데이터 영역에 할당된 데이터를 읽는 것으로 바이트코드에서 명령들을 한 줄 한 줄 실행합니다. 

### 3.1) 인터프리터(Interpreter)

인터프리터는 바이트코드를 해석하고 명령을 한 줄 한 줄 실행 합니다. 이런 이유로 빠르게 바이트코드 한줄을 해석할 수 있습니다. 그러나 해석된 결과를 실행하는 것은 느린 작업입니다. 단점은 하나의 메소드가 여러 번 호출된 때 매번 새로운 명령과 느린 실행을 필요하다는 것입니다.

### 3.2) Just-In-Time(JIT) 컴파일러

오직 인터프리터만 사용할 수 있다면, 하나의 메소드가 여러 번 호출 될 때 , 해석 또한 매번 발생할 것이고, 그것은 호출적으로 처리하면 불필요한 작업입니다.이는 JIT 컴파일러로 가능하게 되었습니다. 첫번째로, 전체 바이트코드를 native 코드(기계어)로 컴파일 합니다. 그런 다음 반복되는 함수 호출의 경우 native 코드를 직접적으로 제공하고 native 코드를 사용하는 실행은 하나하나 해석하는 명령보다 훨씬 빠릅니다. Native 코드는 캐시에 저장되고 그렇기 때문에 컴파일 된 코드가 빠르게 실행될 수 있습니다.

하지만 JIT 컴파일의 경우에도 인터프리터가 해석하는 것 보다 컴파일하는데 더 오랜 시간이 걸립니다. 딱 한번만 실행하는 코드 세그먼트(segment) 경우 컴파일하는 대신에 해석하는 것이 더 좋습니다. 또한 native 코드를 캐시에 저장하는 것은 비싼 리소스입니다. 이런 상황에서 JIT 컴파일러는 내부적으로 메소드 호출의 빈도수를 확인하고 선택된 메소드가 일정 수준 이상 발생했을 때만 컴파일하는 것을 결정합니다. 적응형 컴파일(adaptive compiling )의 아이디어는 `Oracle Hotspot VM`에서 사용되었습니다.

실행 엔진은 JVM 공급 업체가 성능 최적화를 도입할 때  핵심 하위 시스템이 될 수 있습니다. 이러한 노력 중에 아래 4가지 구성 요소가 성능을 크게 향상시킬 수 있습니다.

*	중간 코드 생성기는 중간 코드를 생성합니다.

*	코드 최적화는 위에서 생성된 중간 코드를 최적화 합니다.

*	타깃 코드 생성기는 Native 코드를 생성합니다

*	프로파일러는 특별한 구성 요소이고, 성능 병목을 찾습니다. (예: hotspots)

컴파일 최적화를 위한 공급 업체 접근 방식

-	*Oracle Hotspot VMs*

Oracle은 JIT 컴파일러 모델인 Hotspot 컴파일러로 표준 Java VM을 2가지로 구현합니다. 프로파일링을 통해 JIT에게 가장만은 컴파일을 요구하는 hotspot을 확인한 다음 코드에서 성능에 중요한 부분을 네이티브 코드로 컴파일 할 수 있습니다. 시간이 지남에 따라 이러한 컴파일된 메소드가 더 이상 빈번하게 불리지 않는다면, 더 이상 hotspot이 아닌 메소드를 식별하고, 캐시에서 native 코드를 빠르게 제거한 다음 인터프리터 모드로  실행을 시작합니다. 이 방법론은 성능을 향상시키고, 거의 사용되지 않는 코드의 불필요한 컴파일을 피하도록 합니다. 추가적으로,  Hotspot 컴파일러는 라이닝과 같은 기술을 컴파일된 코드를 최적화하는 방법을 결정합니다. 컴파일러에 의한 런타임 분석은 최적화에 가장 큰 성능 향상을 가져오는 결정을 할 때 추측을 제거할 수 있습니다.

JVM들은 동일한 런타임(인터프리터, 메모리, 스레드)을 사용하지만 아래의 언급처럼 JIT 컴파일러의 맞춤형 구현을 사용합니다.

*	Oracle Java Hotspot Client VM은 Oracle JDK와 JRE을 위한 기본 JVM 기술입니다. 이것은 어플리케이션의 시작 시간과 메모리 공간을 줄임으로써 클라이언트 환경에서 어플리케이션이 실행될 때 최적의 성능을 위해 조정되었습니다.

*	Oracle Java Hotspot Serve VM은 서버 환경에서 실행하는 어플리케이션을 위해 최대 프로그램 실행 속도를 위해 디자인되었습니다. 여기서 사용되는 JIT 컴파일러는 Advanced Dynamic Optimizing Compiler로 불리며 더 복잡하고 다양한 성능 최적화 기술을 사용합니다. Java HotSpot Server VM은 서버 커맨드라인 옵션을 사용하는 것으로 호출됩니다.

Oracle의 Java Hotspot 기술은 빠른 메모리 할당, 빠르고 효율적인 GC, 그리고 크게 공유되는 메모리 멀티 프로세서 서버에서 쉽게 확장 가능한 스레드 핸들링 효율로 유명합니다.

-	*IBM AOT (Ahead-Of-Time) 컴파일*

이 JVM들은 공유되는 캐시를 통해 컴파일된 native 코드를 공유하는 것이 특징입니다. 그러므로 AOT 컴파일러로 이미 컴파일된 코드는 컴파일없이 다른 JVM에서 사용될 수 있습니다. 추가로 IBM JVM은 AOT 컴파일러를 사용해서 코드를 JXE(Java Executable) 파일 포맷으로 코드를 사전 컴파일하는 빠른 실행 방법을 제공합니다.

3.3) 가비지 컬렉터(GC)

객체가 참조되고 있는 한, JVM은 객체가 살아있다고 간주합니다. 객체가 더 이상 참조되지 않아서 어플리케이션 코드에서 도달할 수 없어지면 가비지 컬렉터는 객체를 제거하고 사용되지 않는 메모리를 회수합니다. 일반 적으로 가비지 컬렉터는 내부에서 동작합니다. 하지만 `System.gc()` 메소드를 호출하는 것으로 그것을 트리거 할 수 있습니다(다시 실행하는 것은 보장되지 않습니다. 따라서 `Thread.sleep(1000)을 호출하고 GC가 완료될 때까지 기다리십시오) .

## 4) Java Native Interface(JNI)

이 인터페이스는 Native Method Libraries의 실행이 요구되고 와 상호작용하는데 사용되고, Native Libraries와 같은 효과를 제공합니다. JVM이 C/C++ 라이브러리를 호출하는 것으로 활성화하고, 하드웨어에 특정한 C/C++ 라이브러리에 의해 호출 될 수 있습니다.

## 5) Native Method Libraries

이것은 실행 엔진이 요구되고 제공되는 Native Interface를 통해 접근될 수 있는 C/C++ Native 라이브러리들의 집합입니다.

# JVM Threads

Java 프로그램이 어떻게 실행되는지에 대해서 알아보았지만 Thread에대해서는 구제척으로 언급하지 않았습니다. 사실은 앞에서 설명한 각 작업를 실행하기 위해서 JVM은 다중 스레드로 동시에 실행합니다. 이 스레드들 중 일부는 프로그래밍 로직을 담고있고, 프로그램(어플리케이션 스레드)에 의해 생성됩니다. 나머지는 시스템(시스템 스레드)에서 백그라운드 작업로  JVM 스스로 생성됩니다.

주요 어플리케이션 스레드는 `public static void main(String[])` 호출로 일부 생성되고 와 모든 다른 프로그램 스레드를 생성하는 main 스레드 입니다. 어플리케이션 스레드는 `main()` 메소드로 시작하는 명령 실행과 만약 어떤 메소드 로직 등에서 `new` 키워드를 찾는 다면 Heap 영역에 객체를 생성하는 같은 작업를 수행합니다.

주요 시스템 스레드는 다음과 같습니다

*	컴파일러 스레드: 런타임에 바이트코드에서 native 코드로의 컴파일합니다.

*	GC 스레드: 모든 GC과 관련된 활동을 합니다.

*	주기적인 작업 스레드: 주기적인 작업의 실행을 스케쥴하기위한 타이머 이벤트(i.e. 인터럽트)는 여기서 수행합니다.

*	Signal dispatcher 스레드: JVM 프로세스에서 보내는 signal를 받고 적절한 JVM 메소드를 호출하는 것으로 JVM안에서 제어합니다.

*	VM 스레드: 전제 조건으로 일부 연산은 Heap 영역 수정이 더 이상 일어나지 않는 안전한 위치에 도달하기위해 JVM 이 필요합니다. 이러한 시나리오를 예는 “stop-the-world” 가비지 컬렉션, 스레드 스택 덤프, 스레드 유예, 그리고 편향된 Lock 해지가 있습니다.

이해를 위한 일부 포인트

*	Java는 해석 및 컴파일 된 언어 입니다.

*	동적 링킹 및 런타임 해석으로 인해 Java가 느려집니다.

*	JIT 컴파일러는 바이트코드 대신 native 코드를 유지함으로 반복 작업에 대한 인터프리터의 단점을 보완합니다.

*	최신 Java 버전은 원래 아키텍처에서 성능 병목 현상을 해결합니다.

*	JVM은 사양일 뿐입니다.  공급 업체는 구현하는 동안 자유롭게 사용자 정의, 혁신 및 성능을 향상시킬 수 있습니다.

