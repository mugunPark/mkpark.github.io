## 객체 지향 프로그래밍

    프로그래밍 패러다음 중 하나로, 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그객체들간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법

* 특징: 
    * 캡슐화 - 데이터(속성)와 데이터를 처리하는 함수를 하나로 묶에 외부로 데이터를 노출시키지 않는것
    * 추상화 - 공통 속성과 행위를 추상화
    * 상속성 
    * 다형성 - Overriding과 Overloading을 통해 상황에 따라 다른 의미로 해석되도록하는 것
* 장점: 재사용성이 용이, 생산성 향상, 유지 보수성이 좋음.
* 단점: 설계시 많은 시간과 노력이 필요

### 클래스 / 객체

* 클래스: 어떤 문제를 해결하기 위한 속성과 행위를 변수와 메소드로 정의한 것
* 객체: 클래스에서 정의한 것을 토대로 실제 메모리상에 할당된 것

### SOLID 원칙

* 단일 책임 원칙 : 클래스는 단 하나의 책임을 가져야하고, 단 하나의 변경 이유를 가져야함.
* 개방 패쇄 원칙: 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야한다.
* 리스코프 치환 원칙: 상위 타입의 객체를 하위 타입의 객체로 치환해도 프로그램은 정상동작 해야한다.
* 인터페이스 분리 원칙: 자신이 사용하지 않는 메서드에 의존하지 않아야함.
* 의존 역전 원칙: 추상화에 의존하고 구체화에 의존하지 않아야함.

## REST API란? 

    HTTP 통신에서 어떤 자원에 대한 CRUD 요청을 Resource와 Method로 표현하여 특정한 형태로 전달하는 방식

### 구성요소

* Resource - 서버는 Unique한 ID를 가지는 Resource를 가지고 있고, 클라이언트는 이러한 Resource에 요청을 보냅니다. 

* Method - 서버에 요청을 보내기 위한 방식으로 GET, POST, PUT, DELETE가 있습니다.

* representation of Resource - 클라이언트와 서버가 데이터를 주고받는 형태를 말합니다.

### 특징

* Uniform Interface - URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일을 말합니다.
* Stateless - 각각의 요청을 별개의 것으로 인식하고 처리하며, 이전 요청이 다음 요청에 연관되면 안됨.
* Cacheable - HTTP라는 기존 웹 표준을 그대로 사용하기 때문에, 웹에서 사용하는 기존 인프라를 그대로 활용가능합니다.
* Self-descriptiveness - 요청 메시지만 보고도 이를 쉽게 이해할 수 있는 자체 표현 구조로 되어있음
* Client - Server 구조
* 계층 구조 - 다중 계층으로 구성될 수 있으며 보안, 로드 밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘수 있고, PROXY, 게이트웨이 같은 네트워크 기반의 중간매체를 사용할 수 있음.

### 장점

1. Open API를 제공하기 쉽다.
3. 원하는 타입으로 데이터를 주고 받을 수 있다.
4. HTTP를 그대로 사용할 수 있다.

### 단점

1. 사용할 수 있는 메소드가 4가지 밖에 없다.
2. 명확한 표준이 없다

## TDD란?

    기능 개발을 할 때 테스트케이스를 먼저 작성하고 그 테스트를 통과하는 코드를 작성하는 개발 방법

### 장점

* 테스트 코드를 먼저 작성하기 때문에 더 명확한 기능가 구조를 설계할 수 있음.
* 테스트 커버리지가 높아짐
* 디버깅 시간을 줄여줌
* 테스트 코드 자체가 문서의 역할을 함.

## 프로세스 vs 스레드

* 프로세스 - 실행되고 있는 프로그램을 의미하고, 운영체제로부터 시스템 자원을 할당받음. 각각의 프로세스는 독립된 메모리를 할당받음.

* 스레드 - 프로세스내에서 실행되는 여러 흐름 단위이고, 프로세스내의 자원을 공유함.

### 멀티 프로세스

    각각의 프로세스가 독립된 구조기 때문에 안정성이 높지만, Context Switching으로 인한 성능 저하가 발생할 수 있음.

### 멀티 스레드

    메모리 공유로 인한 시스템 자원 소모가 감소하고, 응답시간이 단축되지만, 자원 공유로 인해 Race condition이 발생할 수 있고, 디버깅이 어려움.

## MVC1, MVC2 패턴의 차이점
* MVC1 - JSP 페이지에 비지니스 로직과 HTML 코드 모두 들어있고, 요청과 응답을 JSP\rk ekaekd
    * 장점: 단순한 페이지 작성으로 쉽게 구현 가능
    * 단점: 웹 애플리케이션이 복잡해지면 유지보수가 힘들다.
* MVC2 - 서블릿에서 요청을 처리하고 그 결과를 JSP 페이지가 표시현함.
    * 장점: 비지니스 로직의 분리로 유지보수와 확장이 용이하다.
    * 단점: 구조 설계를 위한 시간이 많이 소요되서 개발 기간이 증가

## Spring Framework 란?
자바 엔터프라이즈 개발을 편하게 해주는 프레임워크로 IOC Container를 통해 객체의 라이프 사이클을 관리하고, 의존성을 주입해주고, 확장성이 높으며, AOP를 제공합니다.  

## Ioc

## Spring Framework의 요청에 대한 동작 순서

요청 -> DispatcherServlet 받아서 -> HandlerMapping가 요청을 처리할 Controller를 검색  -> Controller가 요청을 받아서 -> Service에서 비지니스 로직 처리 -> Controller -> DispatcherServlet -> 페이지를 보여줘야하는 경우 ViewResolver 페이지 정보를 찾아서 -> DispatcherServlet -> 화면에 표시

## Component vs Controller vs Repository vs Service

* Component - Spring에서 관리되는 객체임을 표시하는 annotation
* Controller - RequestMapping을 하기위한 annotation
* Repository - 데이터 저장소를 나타내는 annotation
* Service - 비지니스 로직의 구현이나 Repository를 호출하는 클래스임을 나타내는 annotation

## GC
새롭게 생성한 객체의 대부분은 Yong Generation 영역에 위치하게 되는데 대부분의 객체가 금방 접근 불가능 상태가 되기 때문에 많은 객체가 생성되었다 사라지고 이때 Minor GC가 발생하고,
Yong Generation에서 살아남은 객체가 Old Generation 영역으로 옮겨지는데 여기서 객체가 사라질 떄 Major GC가 발생함.

Young Generation에는 Eden과 Survivor 2개의 영역이 존재하는데 새로 생성된 객체는 Eden영역에 위치하게되고 Eden에서 GC 후 살아남은 객체는 Survivor 영역으로 이동되어 계속 쌓이다가 Survivor 영역이 가득 차게되면 GC 이후 살아남은 객체들이 다른 Survivor 영역으로 이동하고 Survivor를 비우는데 이러한 과정이 반복되다가 오래도록 살아남은 객체는 Old Generation으로 이동합니다. Suvivor 영역은 둘중 하나는 반드시 비어있는 상태로 남아있어야합니다.   

Old 영역의 GC에는 Serial, Parallel, Parallel Old, Concurrent Mark & Sweep, G1 GC가 있습니다.

https://d2.naver.com/helloworld/1329

### Serial GC
     
    mark-sweep-compact라는 알고리즘을 사용하고, 첫 단계로 Old영역에 살아 있는 객체를 식별(Mark)하고, 다음으로 Heap의 앞 부분부터 확인하여 살아있는 객체남 남기고(Sweep), 마지막으로 힙의 가장 앞 부분부터 채워서 객체가 존재하는 부분과 객체가 없는 부분으로 나눕니다(Compaction).

### Parallel GC

    Serial GC와 기본적인 알고리즘은 같고, Serial GC는 스레드가 하나인 것에 비해, Parallel GC는 여러개의 쓰레드가 처리합니다. 그렇기 때문에 빠르고 메모리가 충분하고 코어의 개수가 많을 때 유리합니다.

### G1 GC

     바둑판의 각 영역에 객체를 할당하고 GC를 실행합니다. 해당 역역이 꽉 차면 다른 영역에서 객체를 할당하고 GC를 실행합니다. 제일 빠르고, JDK 7 에서 정식으로 포함하여 제공되었습니다.  


## 마이크로서비스 아키텍처(MSA)

모놀리식 아키텍처 모든 기능이 단일 서비스에 있기 때문에 서비스가 커지면 코드가 방대해지고 방대해진 만큼 빌드 및 배포 시간이 길어지고, 기능 추가와 개선하기가 복잡해지고, 오류 발생시 서비스 전체에 영향을 주는 등의 이러한 문제를 해결하기 위해 큰 서비스를 독립적인 역할을 수행하는 작은 단위의 서비스로 분리해서 설계하는 SOA(Service Oriented Archiectrue)에 근간을 두고있는 아키텍쳐

장점은 작고 독립적인 서비스간에 느슨하게 결합되어있기 때문에 유지 관리가 쉽고, 서비스를 독립적으로 배포 가능하기 때문에 배포 시간이 절약되고, 확장성적인 측면에서도 유리합니다.

단점은 네트워크를 통해 데이터를 주고받아야하기 때문에 모놀리식보다 시간이 추가로 더 소요되고, 아무래도 각각의 서비스들이 분리되어 있기때문에 다른 서비스에 의존성이 있는 기능에 대한 테스트가 더 어렵습니다. 그리고 서비스간의 트렌책션 처리가 어렵습니다.


## 정렬 알고리즘

### 선택 정렬

    맨 앞의 인덱스부터 현재 인덱스를 포함한 이후의 배열 값 중 가장 작은 값을 찾아서 현재 인덱스와 찾은 인덱스의 값을 바꿔주면서 순차적으로 정렬을 진행. 복잡도는 O(n^2)

### 버블 정렬

    두개의 인접한 Index를 비교해서 큰 값을 뒤로 보내는 작업을 반복하면서 정렬을 진행 시간 복잡도 - 평균 : O(n^2)

### 삽입 정렬

    두 번째 인덱스부터 시작하고, 이전 인덱스의 값들과 비교하여 자신이 들어가 위치에 삽입해서 정렬 진행  시간 복잡도 - 평균 : O(n^2)

### 병합 정렬

    배열을 크기의 절반으로 나누고 또 이들을 재귀 호출을 이용해 각각 정렬한 후 정렬된 배열을 하나로 합치는 방식.     시간 복잡도 - 	O(n log n)

### 퀵 정렬 (아직 잘 이해안됨)  별 1000000개

    배열을 pivot의 값을 기준으로 작은 값을 왼쪽으로 큰값을 오른쪽으로 보내고, pivot의 왼쪽/오른쪽을 다시 pivot의 값을 기준으로 작은 값을 왼쪽으로 큰값을 오른쪽으로 보내면서 반복하면서 정렬하는 방식
    시간 복잡도 - 평균 : O(n log n)   / 최악: O(n^2)

    최악의 경우 - 이미 정렬된 데이터에서 피벗을 시작 또는 끝값으로 선택하였을 때


## 검색 알고리즘

### 이진 탐색(Birnary Search)

    오름 차순으로 정렬된 리스트에서 특정 값의 위치를 찾기위한 알고리즘으로 배열의 중간 값과 찾고자 하는 값을 비교여 중간 값이 클 경우에는 중간 값 좌측의 데이터들을 중간값이 작은 경우 우측의 데이터를 대상으로 동일한 방식을 재귀적으로 호출하면서 값을 찾을 때까지 반복합니다. 정렬된 리스트에만 사용할 수 있다는 단점이 있고, 시간 복잡도 O(logN) 

## ArrayList vs LinkedList 차이

    |ArrayList|LinkedList|
    |내부적으로 배열을 사용하기 때문에 메모리에 연속된 공간에 저장|서로 주고 값으로 다음 위치를 알고있음|
    |배열 중간의 데이터를 삽입/삭제가 일어나면 뒤에 있는 모든 데이터의 이동하고, 또한 삽입할 때 배열의 크기를 초과하게 되면 배열 복사가 발생함, 검색에 빠름|삽입과 삭제할 때 빠름|


# 프론트엔드

## ES6 특징

* block-scpoe인 let과 const 
* 함수 디폴트 파라미터 , Spread Operator
* 템플릿 리터럴 
* Arrow Function 
* Promise
* Class / Module

## 실행 컨텍스트(Execution Context)

* 전역 실행 컨텍스트 - 전역 변수, 전역 함수를 포함하는 전역 객체를 생성하고, this에 전역 객체를 할당
* 함수 실행 컨텍스트 - 함수 호출 마다 생성되며, 
* Eval 함수 실행 컨텍스트 

### Execution Context의 3가지 객체

* 변수 객체 - 변수, 매개변수, argument, 함수 표현식을 제외한 함수 선언 정보가 있음.
* 스코프 체인 - 전역 객체와 중첩된 함수의 스코프의 레퍼런스를 저장하고 있는 일종의 리스트
* this - 함수 호출의 패턴에 의해 결정 (함수 호출, 메소드 호출, 생성자 호출, appy/call/bind 호출)

## Promise

    비동기를 위한 중첩되는 콜백으로 생기는 문제들을 해결하기 위한  패턴으로 비동기 작업을 Promise 체이닝을 통해 코드 가독성을 좋게하고 오류에 대한 처리도 좋게합니다.

## 클로저

    외부 함수의 변수에 접근할 수 있는 내부 함수이며, 외부 함수가 리턴된 이후에도 외부 함수의 변수에 접근할 있음. 지역 범위, 외부 함수 범위, 전역 범위를 가집니다.

## var, let, const 차이

    var - function scope / let, const - block-scope

## 호이스팅 
    
    함수 안에 있는 선언부를 함수 유효범위 최상단으로 옮기는 것.