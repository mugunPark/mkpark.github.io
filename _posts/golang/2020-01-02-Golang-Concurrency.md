---
title: "Achieving concurrency in Go"
classes: wide
excerpt: "[원문] Achieving concurrency in Go"
header:
  overlay_image: /assets/images/develop-unsplash.jpg
  overlay_filter: rgba(255, 255, 255, 0.3)
  actions:
    - label: "Go to"
      url: "https://medium.com/rungo/achieving-concurrency-in-go-3f84cbf870ca"
categories:
  - Golang
tags:
  - goroutine
  - concurrency
last_modified_at: 2020-01-02T17:00:00
---

Go의 멋진 기능을 하나 선택한다면, 그것은 내장 되어있는 동시성 모델(고 루틴)일 것입니다. 동시성을 지원하는 것 뿐만아니라 그것을 더 나은 성능을 제공합니다.

# 동시성이란?

컴퓨터 프로그래밍에서 동시성은 한번에 여러 가지를 처리할 수 있는 컴퓨터의 능력입니다. 예를 들어 브라우저에서 인터넷 서핑을 한다면 아마 한 번에 많은 일이 일어날 것입니다. 특별한 상황에서 스크롤 중인 페이지에서 어떤 음악을 듣는 동안에 어떤 파일을 다운로드를 동시에 할 수도 있습니다. 브라우저가 그것들을 한번에 처리할 수 없다면 모든 다운로드가 완료될 때 까지 대기 해야하며 그 다음 다시 인터넷을 사용할 수 있을 것입니다. 그것은 아마 당신을 좌절시킬 것입니다.

일반적인 PC는 모든 처리 및 계산을 하는 CPU 코어가 하나만 있을 수 있습니다. CPU 코어는 한 번에 한 가지만 처리할 수 있습니다. 동시성에 대해 말할 때 한 번에 한 가지만 처리하는데 처리될 필요가있는 작업 간에 CPU 사용 시간을 나눕니다. 이런 이유로 실제로 동일한 시간에 여러 가지 일이 일어나는 느낌을 받습니다. 그러나 실제로는 한 번에 한 가지 일만 합니다.

CPU 관리 웹 브라우저가 어떻게 우리가 이야기 한 예와 같은 것을 관리하는지 다이어그램을 봅시다.


![image-center]({{ site.url }}{{ site.baseurl }}/assets/images/web-concurrency.jpg){: .align-center}

위의 다이어그램에서 싱글 코어 프로세서가  각 작업의 우선 순위를 기반으로 작업량을 매우 많이 나눈것을 볼 수 있습니다. 예를 들어 페이지를 스크롤하는 동안 듣는 음악은 아마 우선 순위가 낮을 것이고, 그렇기 때문에 때로는 인터넷 속도가 느리면 음악이 멈출 수 있지만 페이지 스크롤은 가능할 수 있습니다. 

# 병렬화란?

하지만 CPU에 여러 개의 코어가 있다면 어떨까요? 프로세서 여러개 있는 것을 멀티 코어 프로세서라고 합니다. PC, 노트북, 스마트폰를 구매할 때 이 용어를 들어보셨을 것입니다. 멀티 코어 프로세서는 한번에 여러 가지 작업을 처리할 수 있는 능력이 있습니다.

이전 웹 프라우저의 예에서 싱글 코어 프로세서는 작업들 사이에 CPU 사용 시간을 나누어야 했습니다. 멀티 코어 프로세서는 다른 코어에서 한번에 별도의 작업을 실행할 수 있습니다. 아래 다이어그램을 봅시다.

![image-center]({{ site.url }}{{ site.baseurl }}/assets/images/web-parallelism.jpg){: .align-center}

병렬로 서로 다른 작업들을 실행하는 개념이 병렬화입니다. CPU가 멀티 코어를 가지고 있을 때 한 번에 여러 작업을 위해 서로 다른 CPU 코어를 사용할 수 있습니다. 그렇기 때문에 빠르게 작업을 완료할 수 있다고 말할 수 있지만 그렇지 않습니다. 나중에 이것에 대해 다시 이야기 하겠습니다.

# 동시성 vs 병렬화

Go는 하나의 코어에서 고 루틴을 사용하는 것을 권장하지만, 다른 프로세서 코어에서 gotoutine을 실행하도록 Go 프로그램을 수정할 수 있습니다. 지금은 Go를 만든 개발자들이 고 루틴을 Go의 함수처럼 생각하고 있기 때문이기도 하지만 다른 이유도 있습니다.

동시성과 병렬화 사이에는 몇 가지 차이점이 있습니다. **동시성은 여러 작업을 한 번에 처리하지만, 병렬화는 여러 작업을 한 번에 실행합니다.**  병렬화가 항상 동시성보다 좋은 것은 아닙니다. 그 이유는 곧 다른 글에서 알아보도록 하겠습니다.

이 시점에서 머릿속에 많은 질문들이 있을 것이고 동시성에 대한 개념을 잡았을 수도 있지만, Go에서 구현한 방법과 그것을 사용하는 방법이 궁금할 것입니다. Go의 동시성 아키텍처와 그것을 사용하는 것 뿐만 아니라 언제 사용하면 되는지 이해하기 위해서 컴퓨터의 프로세스를 이해할 필요가 있습니다.

# 컴퓨터 프로세스란?

C, JAVA, GO 같은 언어로 작성한 컴퓨터 프로그램은 단지 텍스트 파일입니다. 하지만 컴퓨터는 0과 1로 구성된 바이너리만 이해하기 때문에 그것을 기계어로 컴파일을 해야합니다. 이것은 컴파일러가 합니다. Python, Javascript와 같은 스크립트 언어는 인터프리터가 합니다.

컴파일된 프로그램이 OS에서 처리될 때 OS는 메모리 주소 공간, 프로그램 카운터(Progrom counter), PID(Process ID) 그리고 다른 매우 중요한 것들을 할당합니다.
프로세스는 메인 스레드를 포함한 하나 이상의 스레드를 가지며 메인 스레드가 여러 개의 다른 스레드를 생성할 수 있습니다. 메인 스레드 실행이 종료되면 프로세스는 종료합니다.

따라서 프로세스가 컴파일된 코드, 메모리 OS 자원, 스레드에 제공될 수 있는 것들을 포함한다는 것을 이해했습니다. 간단히 말하면, 프로세스는 메모리에 있는 프로그램입니다. 그렇다면 스레드는 무엇이고, 작업은 무엇일까요?  

# 스레드란?

스레드는 프로세스 안에 있는 작은 프로세스 입니다. 스레드는 코드 조각을 실질적인 실행기 입니다. 스레드는 프로세스에서 제공하는 메모리, OS 자원등에 접근합니다.

코드가 실행 중인 동안에 메모리 영역의 스레드 저장소 변수(데이터)는 변수가 임시 공간을 보유하는* scratch space*인 *stack* 입니다. stack은 컴파일때 생성되고 일반 적으로 1-2MB의 고정된 사이즈 입니다. 스레드에서 stack이 오직 해당 스레드에서만 사용될 수 있고, 다른 스레드와 공유될 수 없습니다.
Heap은 데이터가 다른 스레드에 의해 접근 가능하는한 메모리 공간을 공유합니다.

지금까지 프로세스와 스레드의 일반적인 개념을 알아보았습니다. 프로세스와 스레드의 용도는 무엇일까요?

웹 부라우저를 시작할 때 무언가를 하기위해 OS 명령인 코드가 있어야합니다. 이것은 우리가 프로세스를 만들고 있음을 의미합니다. 그 프로세스는 아마 OS에 새로운 탭 생성을 위해 새로운 프로세스를 생성하는 것을 요청할 것입니다. 브라우저 탭을 열고 일반적으로 브라우저에서 무엇인가를 하면 브라우저 탭의 프로세스는 다른 행동에 대한 또 다른 프로세스를 생성하고 시작할 것입니다.

아래의 이미지는 크롬의 프로세스 캡처 화면입니다.

![image-center]({{ site.url }}{{ site.baseurl }}/assets/images/process-chrome.png){: .align-center}

이미지는 크롬 브라우저가 열린 탭과 내부 서비스를 위해 다른 프로세스를 사용중인 것을 보여줍니다. 각 프로세스에 하나 이상의 스레드가 있으므로 크롬 프로세스는 스레드가 10개 이상 있음을 알 수 있습니다.  

위에서 여러 작업 다루고 여러 작업을 실행하는것에 대해 이야기 했었습니다. 여기에서 작업은 스레드에서 실행되는 활동들입니다. 그렇기 떄문에 여러 작업이 동시성 또는 병렬화에서 일어납니다. 작업들은 순차적이거나 병렬로 여러 스레드에서 실행합니다.

  멀티 스레드에서 프로세스가 생성하는 여러 스레드에서 메모리 릭이 있는 스레드는 다른 스레드의 자원을 소모하며 프로세스가 응답하지 않을 수 있습니다. 브라우저나 어떤 프로그램을 사용할 때 많이 보았을 것입니다. 응답하지 않는 프로세스는 작업 관리자에서 종료할 수 있습니다.

# 스레드 스케줄링

다중 스레드가 순차적 또는 병렬로 실행 중일 때, 스레드 간에 데이터가 공유되므로 중요한 데이터는 한번에 하나의 스레드만 접근할 수 있게 조절하는 작업이 필요합니다. **일정 순서로 여러 스레드의 실행하는 것을 스케줄링이라고 합니다.** OS 스레드는 커널에 의해 스케줄되고, 일부 스레드는 JRE와 같은 프로그래밍 언어의 실행 환경에 의해 관리됩니다. 여러 스레드가 동일한 시간에 동일한 데이터에 엑세스하려고 하면 데이터가 변경되거나 예상하지 못한 결과 발생하고 Race Condition이 발생합니다.

# Go에서 동시성

마침내 Go에서 동시성을 구현하는 방법에 대해 이야기하기 위한 장소로 왔습니다. Java와 같은 전통적인 언어는 현재 프로세스에서 여러 스레드를 생성하기위해 사용될 수 있는 Thread 클래스를 가지고 있습니다. 
Go는 전통적인 OOP 문법을 가지지 않기 때문에 고 루틴 생성하기 위해 go 키워드를 제공합니다. go 키워드가 함수 호출 앞에 위치하면 그것이 고 루틴가 됩니다.

고 루틴는 스레드처럼 동작하지만 스레드에 대한 추상화 입니다. 조금 뒤에 스레드와 고 루틴을 다른점을 알아보겠습니다.

Go 프로그램을 실행할 때 Go 런타임은 모든 고 루틴가 다중화되는 코어에 스레드를 거의 생성하지 않습니다. 언제든지 하나의 스레드는 하나의 고 루틴으로 실행될 것이고, 그 고 루틴이 블럭되면 해당 스레드에서 대신 실행되는 다른 고 루틴으로 교체됩니다. 스레드 스케줄링과 같지만 Go 런타임에 의해 처리되고 매우 빠릅니다.

하나의 코어에서 모든 고 루틴을 실행하는 것을 대부분의 경우 권장하지만 사용가능한 CPU 코어에서 고 루틴를 분리할 필요가 있다면 GOMAXPROCS 환경 변수를 사용하거나 런타임에 runtime.GOMAXPROCS(n) 함수를 호출할 수 있고 n은 사용할 코어의 수 입니다. 하지만 때로는 GOMAXPROCS 1보다 크게 설정하는 것은 프로그램을 더 느리게 만든다고 느낄것 입니다. 그것은 실제로 프로그램에 따라 다르지만 인터넷에서 문제의 솔루션 또는 설명을 찾을 수 있을 것입니다. 무언가를 계산하는 시간보다 channel를 통해 통신하는데 더 많은 시간을 사용하는 프로그램은 다중 코어, OS 스레드, 프로세스들을 사용할 때 성능이 나빠지는 것을 경험할 것입니다.

Go는 여러 프로세서를 활용할 수 있는 M:N 스케줄러가 있습니다. groutines(M)은 대부분의 GOMAXPROCS 프로세서의 수에서 실행되는 OS 스레드(N)에서 항상 스케줄될 필요가 있습니다. 언제든지 코어 당 최대 하나의 스레드만 실행되게 할 수 있습니다. 그러나 스케줄러는 필요하다면 더 많은 스레드를 생성할 수 있지만, 거의 발생하지 않습니다. 프로그램에서 추가적인 고 루틴을 시작하지 않으면, 사용 가능한 코어 수에 관게없이 하나의 스레드에서만 자연스럽게 실행합니다.

# 스레드 vs 고 루틴

이전에 보았던것 처럼 스레드와 고 루틴 사이에는 명백한 차이가 있지만 아래의 차이점은 고 루틴 보다 스레드가 더 비싼 이유와 고 루틴이 응용 프로그램에서 최고 수준의 동시성을 달성하는 핵심 솔루션인 이유인지 설명해줄 것입니다.

|스레드|고 루틴|
|-----|-------|
|OS 스레드는 커널에서 관리하고 하드웨어에 의존| 고 루틴은 go 런타임에서 관리하고 하드웨어에 의존하지 않음|
|OS 스레드는 일반적으로 1-2M 스택 사이즈로 고정됨| 고 루틴은 대부분 go 최신 버전에서 8KB의 스택 사이즈|
스택 사이즈는 컴파일 타임에 결정되고 증가하지 않음|스택 사이즈는 런타임에 관리되고 Heap 저장소를 할당 및 해제 가능한 1GB 까지 증가할 수 있음|
|스레레드 간에 통신이 쉽지 않고 통신 사이에 대기 시간이 큼 | 고 루틴은 적은 대기 시간으로 다른 고 루틴과 channel을 이용해 통신함|
|프로세스의 각 스레드를 식별하는 TID가 있음| 고 루틴은 TLS(thread Local Storage)가 없기 때문에 구현해야함|
|스레드는 OS에서 많은 자원을 요청하고 완료되면 반환해야하기 때문에 설정 및 해제 비용이 상당히 큼|  고 루틴은 go 런타임에 의해 생성되고 해제됨. go 런타임은 이미 고 루틴에 대한 스레드 풀을 유지하기 때문에 이러한 작업은 스레드에 비해 매우 저렴하고, 이 경우 OS는 고 루틴은 인식하지 못함|
스레드는 우선적으로 스케쥴됨. 스레드 간의 전환 비용은  스케쥴러가 50개 이상의 레지스터와 상태를 저장/복원해하기 때문에 비용이 비쌈.  스레드간에 빠른 전환이 있을 때 이것은 매우 중요할 수 있음.| 고 루틴은 협력해서 스케줄됨. 고 루틴 전환이 발생하면 3개의 레지스터만 저장/복원함|

위의 몇 가지 중요한 차이점이 있지만 자세히 살펴보면 놀라운 Go의 동시성 모델 세계를 찾을 수 있습니다. Go의 동시성의 장점 중 일부를 강조하기 위해 분당 1000개의 요청을 처리하는 웹 서버가 있다고 가정해봅시다. 각 요청을 동시에 실행해야 한다면 그것은 1000개의 스레드를 만들거나 자식 프로세스로 분리할 필요가 있다는 것을 의미합니다. Apache 서버가 요청을 관리하는 방법입니다. OS 스레드가 스래드당 1MB 스택 사이즈를 사용한다면 그것은 트래픽에 1GB의 RAM이 소모한다는 것입니다. Apache는 스레드당 스택 사이즈를 관리하는 ThreadStackSize를 제공하지만  여전히 이로 인해 문제가 발생했는지 전혀 알 수 없습니다.

고 루틴의 경우에는 스택 사이즈가 동적으로 증가할 수 있으므로, 문제없이 1000개의 고 루틴을 만들 수 있습니다. 고 루틴이 8KB 스택 사이즈로 시작하므로 대부분 일잔적으로 스레드보다 더 증가하지 않습니다. 그러나 많은 메모리를 필요로하는 재귀 호출이라면 Go는 스택 사이즈를 1GB까지 늘릴 수 있지만 이는 버그인 for{}를 제외하고는 거의 일어나지 않을 것이라고 생각합니다.

또한 고 루틴 사이의 빠른 전환이 가능하고 스레드와 비교해서 더 효율 적입니다. 하나의 고 루틴은 하나의 스레드에서 실행하고 고 루틴은 협조적으로 스케줄되기 때문에 다른 고루틴은 현재 고 루틴이 블럭 될때 까지 스케줄 되지 않습니다.스레드 블럭의 고 루틴이 사용자 입력 대기 중인 경우 다른 고 루틴이 대신 스케줄됩니다. 고 륀은 다음 조건 중 하나를 차단할 수 있습니다.

* network input

* sleeping

* channel operation

* blocking on primitives in th sync package

고 루틴이 조건 중 하나로 블럭하지 않는 다면 그것은 다중화된 스레드가 기아 상태가 될 수 있고, 다른 고 루틴을 죽일 수 있습니다. 해결 방법이 있지만 해결 방법이 잘못된 경우 잘못된 프로그래밍일 것 입니다.

channel은 고 루틴 사이에서 데이터를 공유하는 중요한 역할을 합니다. channel을 이용하면 스레드의 경우 공유 메모리 엑세스하는 것과는 반대로 고 루틴 사이에 공유된 데이터에 부적절한 엑세스 및 race condition을 예방합니다.